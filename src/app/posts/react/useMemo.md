---
title: "useMemo"
slug: "useMemo"
date: "2025-04-29"
---

## useMemo란?

`useMemo`는 컴포넌트 내에서 **계산 비용이 큰 값들을 메모이제이션(memoization)**하여  
불필요한 재계산을 방지하는 Hook입니다.

특히, 렌더링마다 복잡한 연산을 다시 수행해야 하는 상황에서  
의존성 배열 내의 값이 변경되지 않으면 이전 계산 결과를 재사용해 성능을 최적화할 수 있습니다.

---

## 기본 사용법

```tsx
import { useMemo, useState } from "react";

export default function Fibonacci() {
  const [num, setNum] = useState(1);

  // 재귀적으로 피보나치 수 계산 (비용이 큰 연산)
  const fib = (n: number): number => {
    if (n <= 1) return n;
    return fib(n - 1) + fib(n - 2);
  };

  // num이 변경될 때만 fib(num)을 재계산합니다.
  const result = useMemo(() => fib(num), [num]);

  return (
    <div>
      <p>
        Fibonacci({num}) = {result}
      </p>
      <button onClick={() => setNum(num + 1)}>증가</button>
    </div>
  );
}
```

- 첫 번째 인자로 계산 함수를 넣고,
- 두 번째 인자인 의존성 배열이 변경될 때만 재계산하여,  
  불필요한 계산을 줄입니다.

---

## useMemo의 장점과 주의점

| 장점                 | 설명                                                               |
| :------------------- | :----------------------------------------------------------------- |
| 성능 최적화          | 계산 비용이 큰 연산의 결과를 캐싱하여, 렌더링 성능을 향상시킵니다. |
| 불필요한 재계산 방지 | 의존성이 변하지 않으면 이전 결과를 재사용합니다.                   |

| 주의점           | 설명                                                   |
| :--------------- | :----------------------------------------------------- |
| 과도한 사용 주의 | 모든 연산에 사용하면 오히려 오버헤드가 될 수 있습니다. |
| 캐싱 비용 고려   | 메모리 사용 및 캐시 관리 비용을 고려해야 합니다.       |

---

# 마무리

`useMemo`를 적절히 활용하면  
복잡한 연산의 재실행을 방지하여,  
더 효율적인 컴포넌트 렌더링을 구현할 수 있습니다.

다음에는 **[[useCallback]]**에 대해 알아봅시다!
